
% ======================================================
% compatibility with PGF 2.0
\def\pgfkeysaddvalue#1#2#3{%
  {%
    \toks0{#2}%
    \pgfkeysifdefined{#1}
    {\pgfkeys@temptoks\expandafter\expandafter\expandafter{\csname pgfk@#1\endcsname}}%
    {\pgfkeys@temptoks{}}%
    \toks1{#3}%
    \xdef\pgfkeys@global@temp{\the\toks0 \the\pgfkeys@temptoks \the\toks1}% believe or don't: the spaces are important
  }%
  \pgfkeyslet{#1}\pgfkeys@global@temp%
}

\def\pgfkeys@try{%
  \pgfkeysifdefined{\pgfkeyscurrentpath/.@cmd}%
  {%
    \pgfkeysgetvalue{\pgfkeyscurrentpath/.@cmd}{\pgfkeys@code}%
    \ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text% Hmm... no value
      \pgfkeysifdefined{\pgfkeyscurrentpath/.@def}%
      {\pgfkeysgetvalue{\pgfkeyscurrentpath/.@def}{\pgfkeyscurrentvalue}}
      {}% no default, so leave it
    \fi%
	\let\pgfkeyscurrentkey=\pgfkeyscurrentpath% make sure that \pgfkeys@code doesn't know about 'try'. Important for .is choice
	% FIXME: maybe there are more things like that - also adjust currentname!?
    \expandafter\pgfkeys@code\pgfkeyscurrentvalue\pgfeov%
    \pgfkeyssuccesstrue%
  }%
  {%
    \pgfkeysifdefined{\pgfkeyscurrentpath}%
    {%
      \ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text%
        \pgfkeysvalueof{\pgfkeyscurrentpath}%
      \else%
        \pgfkeyslet{\pgfkeyscurrentpath}\pgfkeyscurrentvalue%
      \fi%
      \pgfkeyssuccesstrue%
    }%
    {\pgfkeyssuccessfalse}%
  }%
}
% ======================================================


% pgfutil@loop (from plain.tex)

\def\pgfutil@loop#1\pgfutil@repeat{\def\pgfutil@body{#1}\pgfutil@iterate}
\def\pgfutil@iterate{\pgfutil@body \let\pgfutil@next\pgfutil@iterate \else\let\pgfutil@next\relax\fi \pgfutil@next}
\let\pgfutil@repeat=\fi % this makes \loop...\if...\repeat skippable

\def\pgfqpointxy#1#2{%
  \pgf@x=#1\pgf@xx%
  \advance\pgf@x by #2\pgf@yx%
  \pgf@y=#1\pgf@xy%
  \advance\pgf@y by #2\pgf@yy}
\def\pgfqpointxyz#1#2#3{%
  \pgf@x=#1\pgf@xx%
  \advance\pgf@x by #2\pgf@yx%
  \advance\pgf@x by #3\pgf@zx%
  \pgf@y=#1\pgf@xy%
  \advance\pgf@y by #2\pgf@yy%
  \advance\pgf@y by #3\pgf@zy}
\def\pgfcoordinate#1#2{%
  \edef\pgf@temp{#1}%
  \ifx\pgf@temp\pgfutil@empty% do nothing
  \else%
    \pgf@process{\pgfpointtransformed{#2}}%
    \expandafter\gdef\csname pgf@sh@ns@#1\endcsname{coordinate}%
    \expandafter\xdef\csname pgf@sh@np@#1\endcsname{%
      \noexpand\def\noexpand\centerpoint{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
    }
    \expandafter\gdef\csname pgf@sh@nt@#1\endcsname{{1}{0}{0}{1}{0pt}{0pt}}%
    \expandafter\global\expandafter\let\csname pgf@sh@ma@#1\endcsname\pgfutil@empty%
    \expandafter\gdef\csname pgf@sh@pi@#1\endcsname{\pgfpictureid}%
  \fi%
}
% ======================================================

\def\pgfutilensuremath#1{%
	\ifmmode#1\else$#1$\fi
}

\tikzoption{ybar}[]{\let\tikz@plot@handler=\pgfplothandlerybar}
\tikzoption{xbar}[]{\let\tikz@plot@handler=\pgfplothandlerxbar}
\tikzoption{ybar interval}[]{\let\tikz@plot@handler=\pgfplothandlerybarinterval}
\tikzoption{xbar interval}[]{\let\tikz@plot@handler=\pgfplothandlerxbarinterval}
\tikzoption{const plot}[]{\let\tikz@plot@handler=\pgfplothandlerconstantlineto}
\tikzoption{const plot mark left}[]{\let\tikz@plot@handler=\pgfplothandlerconstantlineto}
\tikzoption{const plot mark right}[]{\let\tikz@plot@handler=\pgfplothandlerconstantlinetomarkright}
\tikzoption{jump mark right}[]{\let\tikz@plot@handler=\pgfplothandlerjumpmarkright}
\tikzoption{jump mark left}[]{\let\tikz@plot@handler=\pgfplothandlerjumpmarkleft}

\tikzoption{mark}{
	\def\tikz@plot@mark{#1}%
	\def\tikz@temp{none}% this check is relatively new
	\ifx\tikz@temp\tikz@plot@mark
		\let\tikz@plot@mark=\pgfutil@empty
	\fi
}
% the 'every mark' style is new:
\tikzset{
	every mark/.style={},
	mark options/.style={%
		every mark/.style={#1}%
	}}
\def\tikz@@@plot{%
    \def\pgfplotlastpoint{\pgfpointorigin}%
    \tikz@plot@handler%
    \tikz@plot@data%
    \global\let\tikz@@@temp=\pgfplotlastpoint%
    \ifx\tikz@plot@mark\pgfutil@empty%
    \else%
      % Marks are drawn after the path.
      \setbox\tikz@figbox=\hbox{%
        \unhbox\tikz@figbox%
        \hbox{{%
          \pgfinterruptpath%
            \pgfscope%
              \let\tikz@options=\pgfutil@empty%
              \let\tikz@transform=\pgfutil@empty%
			  \tikzset{every mark}%
              \tikz@options%
              \ifx\tikz@mark@list\pgfutil@empty%
                \pgfplothandlermark{\tikz@transform\pgfuseplotmark{\tikz@plot@mark}}%
              \else
                \pgfplothandlermarklisted{\tikz@transform\pgfuseplotmark{\tikz@plot@mark}}{\tikz@mark@list}%
              \fi
              \tikz@plot@data%
            \endpgfscope
          \endpgfinterruptpath%
        }}%
      }%
    \fi%
    \global\setbox\tikz@tempbox=\copy\tikz@figbox%
    %\global\let\tikz@after@path@smuggle=\tikz@after@path
  \endgroup%
  \setbox\tikz@figbox=\box\tikz@tempbox%  
  \tikz@make@last@position{\tikz@@@temp}%  
  %\expandafter\tikz@scan@next@command\tikz@after@path@smuggle%
  \tikz@scan@next@command%
}




% ======================================================


\newif\ifpgfmathcomparison

% Assigns \pgfmathresult to 1.0 if #1 ~= #1.
%
% It will also set the boolean \ifpgfmathcomparison accordingly
% (globally).
\def\pgfmathapproxequalto#1#2{%
	\edef\pgfmath@marshal{%
		\noexpand\pgfmathparse{#2}
		\noexpand\let\noexpand\pgfmath@arg\noexpand\pgfmathresult%
		\noexpand\pgfmathparse{#1}%
	}%
	\pgfmath@marshal%
	\pgfmathapproxequalto@{\pgfmathresult}{\pgfmath@arg}}
\def\pgfmathapproxequalto@#1#2{%
	\begingroup%
		\pgfmath@x#1pt%
		\pgfmath@y#2pt%
		\advance\pgfmath@x-\pgfmath@y%
		\ifdim\pgfmath@x<0pt
			\multiply\pgfmath@x by-1
		\fi
		\ifdim\pgfmath@x<0.0001pt\relax%
			\def\pgfmathresult{1.0}%
			\global\pgfmathcomparisontrue
		\else%
			\def\pgfmathresult{0.0}%
			\global\pgfmathcomparisonfalse
		\fi%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup%
}

\newif\ifpgfmarktext@usetikznode
\pgfkeys{
	/pgf/text mark/.initial=p,
	/pgf/text mark/style/.initial=,
	/pgf/text mark/as node/.is if=pgfmarktext@usetikznode,
	/pgf/text mark/.default=true,
}%

\pgfdeclareplotmark{text}
{
	\pgfkeysgetvalue{/pgf/text mark/style}\pgfmarktext@style
	\pgfkeysgetvalue{/pgf/text mark}\pgfmarktext@
	\ifpgfmarktext@usetikznode
		\expandafter\node\expandafter[\pgfmarktext@style]{\pgfmarktext@};
	\else
		\expandafter\pgftext\expandafter[\pgfmarktext@style]{\pgfmarktext@}%
	\fi
}

% A fix for the overlay option and matrices:
\def\pgf@matrix@startcell{%
  %
  % Step 1: Init the list of nodes for this cell
  %
  \let\pgf@nodecallback=\pgf@matrix@nodecallback%
  %
  % Step 2: Setup the bounding box
  %
  \pgfinterruptboundingbox%
  %
  % Step 3: Reset the transformation matrix
  %
  \pgftransformreset%
  %
  % Step 4: Collect everything in a cell box
  %
  \setbox\pgf@matrix@cell=\hbox\bgroup\bgroup%
	% make sure that cell pictures are not affected if matrizes have
	% 'overlay' option on:
	\pgf@relevantforpicturesizetrue
    \pgfsys@beginpicture%
    \normalbaselines%
    % Find out whether the cell is empty:
    \pgfutil@ifnextchar\let%
    {% ok, candidate, check following symbol
      \afterassignment\pgf@matrix@empty@check\let\pgf@matrix@temp=% get rid of \let
    }%
    {% no, not empty
      \pgf@matrix@empty@cell@false%
      \pgfmatrixbegincode%
    }%
}
